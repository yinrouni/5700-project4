Launch program requires root privileges on the operating system
    make
    ./rawhttpget <URL>

Approach
    In this project, we intend build up a socket based on TCP/IP to deal with HTTP/GET. Here, to initialize such a
    socket, we create 2 raw sockets used for sending and receiving, and initialize some essentials fields in TCP  and
    IP, like seg, ack.

    Generally, it provides following methods:
    - connect(address_tuple): connect local host and remote server.
    - send(request): send a http/GET request, and the name of file for the outpu
    - recv(filename): recv the response from the http/GET sent before, and save in the file named filename
    - close(): close the socket

    At first, to connect the remote serve with the local machine via the socket, our program will parse the given URL
    to get the hostname, and set up IP and port of the remote server by hostname. Get the IP and port of local machine
    using the API of OS on Linux. Keep them as fields in the socket for sending and receiving packets later.

    The communication via this socket is achieved by sending and receiving packet. packet = IP header + TCP header + data

    IP header
0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    TCP header
 0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    To generate packets, we pack the IP header, pseudo header for TCP header's checksum and TCP header according to the
    their format along the payload data.

    Prior to sending HTTP request and get response, we set up the TCP connection through handshake.

    Handshake
        client ---------------------- server
        ----------- SYN seq = x ----------->
        <--SYN, ACK seq = y, ack = x + 1 --
        --- ACK seq = x + 1, ack = y + 1 ---

    Start with sending a SYN to server. Unpack and validate the incoming SYN-ACK packet. Send a ACK for it.

    Once the connection is set up, start from send the HTTP request in PSH-ACK packet then. Verify the checksum, seq and
     ack, source and dest address of incoming packets for the validation, and ACK them. If fails or a packet is not
     ACKed within 1 minute, assume the packet is lost and retransmit it.
        - PSH-ACK seq = x + 1, ack = y + 1, len = z ->
        <----- ACK seq = y + 1, ack = x + 1 + z ------
        <- ACK seq = y + 1, ack = x + 1 + z, len = k -
        --- ACK seq = x + 1 + z, ack = y + 1 + k ---->
                        ...

    In the end, if our program receive a FIN from server, it will reply to this request 
    to tear down the connection, by sending a FIN-ACK. Then receive an ACK from server and 
    tear down the connection.
    reply to disconnect
        <-- PSH,FIN,ACK seq = m, ack = n, len = k --
        ---- FIN, ACK seq = n, ack = m + k + 1 ---->
         <---- ACK seq = m + k + 1, ack = n + 1 ----

    if our program wants to end the connection, exactly when program does not receive any data from the remote server
    for three minutes, we assume that the connection has failed and tear it down. the process are as follow:
        -------- FIN seq = m, ack = n -------->
        <----- ACK seq = k , ack = m + 1 ------
        <---- FIN-ACK seq = w, ack = m + 1 ----
        ---- ACK seq = m + 1 , ack = w + 1 ---->
    

IP features implemented:
connect(): we implemented this function to set up the correct IP and port of the remote server

createIPHeader(): we implemented this function to generated an IP header by setting up essential fields in the header,
                  and setting correct checksum in packet.
                  
unpackIP(): we implement this function to unpacks the incoming IP packet and validating the checksums the incoming packet.
            and it also check the validity of IP headers from the remote server.


TCP features implemented:
createTCPPacket(): we implemented this function to generated an TCP header by setting up essential fields in the header,
                   and Generate pseudo header using 0 as checksum,then replace the checksum calculated by it and repack the returned 
                   TCP header.

unpackTCP(): we implement this function to unpacks the incoming TCP packet and validating the checksums the incoming packet.
             and it also check the validity of TCP headers from the remote server.
             
handshake(): we implemented this function to set up the connect by handshaking. Start with sending a SYN to server. Unpack and
             validate the incoming SYN-ACK packet. Send a ACK for it. Handshake done.

send():      we implemented this function to send request after handshake.Unpack and validate the incoming ACK packet. 
             If it fails validation,resend the request.
             
rev_ack():   we implement this function to Handle the incoming ACK for PSH-ACK when sending http request, and FIN when client wants
             to end the connection.If there's valid ACK within 1 min, assume the sent packet is lost and retransmit. If it does not
             receive any data for 3 min, client start to tear down the connection. And we set the cong cwnd in this function.

recv():      we implement this function to Receive the response of the request. Keep receiving ACK with content from server, 
             and send back ACK for each of them. If there's valid ACK within 1 min, assume the sent packet is lost and retransmit.
             If it does not receive any data for 3 min, client start to tear down the connection. When receiving a packet marked FIN,
             reply to the request from server to end the connection.
             
disconnect() and reply_disconnect(): handle the connection teardown

Challenges faced
    process of handle sequence and acknowledgement numbers
    wireshark captures TCP DUP ACK, we figure out what happend, and solved it.
    
Chihao Sun implements the processing of url and file nameï¼Œstatus code handler and Makefile, and rawhttpget script. 
